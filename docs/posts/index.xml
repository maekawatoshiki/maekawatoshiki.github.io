<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Hello</title>
        <link>https://maekawatoshiki.github.io/posts/</link>
        <description>Recent content in Posts on Hello</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja-jp</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Wed, 19 May 2021 15:56:20 +0900</lastBuildDate>
        <atom:link href="https://maekawatoshiki.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Google Summer of Code 2021 に参加します</title>
            <link>https://maekawatoshiki.github.io/posts/gsoc1/</link>
            <pubDate>Wed, 19 May 2021 15:56:20 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/gsoc1/</guid>
            <description>TL;DR  Google Summer of Code に提出したProposalが採択されました 晴れてGSoCに参加できることとなりました 参加団体はLLVMです 嬉しい  Google Summer of Codeとは  Google Summer of Code is a global program focused on bringing more student developers into open source software development. Students work with an open source organization on a 10 week programming project during their break from school.
(https://summerofcode.withgoogle.com/)
 Google Summer of Code は、OSSプロジェクトにメンター付きで参加することができ、さらに Google から報酬ももらえるイベントです。 その名の通り夏（休み）に行われるのですが、アメリカ規準であって、日本の大学などでは普通に授業が行われています。 本来であれば、学部2年生の私にとっては参加が少し厳しいはずでしたが、今年は新型コロナの影響でプロジェクトに取り組む時間の制約が緩くなった (40h/w→17h+/w) ので、思い切って参加してみました。(大学もずっとオンラインで、家にこもりっぱなしですし。)
Proposal採択までの流れ 3月の初めから、以下の作業を始めました。
参加団体を選ぶ 公式サイトを見れば、様々な団体がGSoCに参加しているとわかります。 私は、ずっと LLVM に貢献したかったので、無論それを選びました。</description>
            <content type="html"><![CDATA[<h1 id="tldr">TL;DR</h1>
<ul>
<li>Google Summer of Code に提出したProposalが採択されました</li>
<li>晴れてGSoCに参加できることとなりました</li>
<li>参加団体はLLVMです</li>
<li>嬉しい</li>
</ul>
<h1 id="google-summer-of-codeとは">Google Summer of Codeとは</h1>
<blockquote>
<p>Google Summer of Code is a global program focused on bringing more  student developers into open source software development. Students work  with an open source organization on a 10 week programming project during their break from school.</p>
<p>(<a href="https://summerofcode.withgoogle.com/">https://summerofcode.withgoogle.com/</a>)</p>
</blockquote>
<p>Google Summer of Code は、OSSプロジェクトにメンター付きで参加することができ、さらに Google から報酬ももらえるイベントです。
その名の通り夏（休み）に行われるのですが、アメリカ規準であって、日本の大学などでは普通に授業が行われています。
本来であれば、学部2年生の私にとっては参加が少し厳しいはずでしたが、今年は新型コロナの影響でプロジェクトに取り組む時間の制約が緩くなった (40h/w→17h+/w) ので、思い切って参加してみました。(大学もずっとオンラインで、家にこもりっぱなしですし。)</p>
<h1 id="proposal採択までの流れ">Proposal採択までの流れ</h1>
<p>3月の初めから、以下の作業を始めました。</p>
<h2 id="参加団体を選ぶ">参加団体を選ぶ</h2>
<p><a href="https://summerofcode.withgoogle.com/organizations/">公式サイト</a>を見れば、様々な団体がGSoCに参加しているとわかります。
私は、ずっと <a href="https://llvm.org/">LLVM</a> に貢献したかったので、無論それを選びました。</p>
<h2 id="参加プロジェクトを選ぶ">参加プロジェクトを選ぶ</h2>
<p>各団体のほぼすべてが、学生向けのプロジェクト一覧を公開しているはずです。LLVM なら<a href="https://llvm.org/OpenProjects.html">ここ</a>。
興味のあるプロジェクトは、初めのうちは複数個選んでおいた方がいいと思います。後になって、選んだプロジェクトが想像以上に難しいものだと判明すると、Proposalを書くのが大変ですし、不必要に自分を追い込んでしまいます。</p>
<h2 id="メーリングリストと奮闘する">メーリングリストと奮闘する</h2>
<p>興味のあるプロジェクトを選んだら、各団体のメンターと連絡を取ります。ここから先は各団体の指示に従うべきです。
私の場合は、メーリングリストでメンターの方にプロジェクトの詳しい説明を聞いていました。<a href="https://lists.llvm.org/pipermail/llvm-dev/2021-March/149058.html">このあたり</a>から辿れます。</p>
<p>(英語のメールを書くのがかなり久しぶりだったので少し緊張しました。)</p>
<h2 id="proposalを書く">Proposalを書く</h2>
<p>各団体に提出するためのProposalを書きます。ネット上には過去GSoCに参加した方のProposalの例が沢山公開されています。</p>
<p><a href="https://docs.google.com/document/d/1UhKyBsVCwuN7VCbaQRVdklY9CCsGM04EcvhLHO0A-UQ/edit?usp=sharing">もちろん私も公開します。</a></p>
<p>Proposalは、ある程度書いたらメンターの人に見てもらって、アドバイスを貰ったりしました。</p>
<h2 id="と同時並行で-小さめのパッチを送る">(↑と同時並行で) 小さめのパッチを送る</h2>
<p>Proposalの内容と関係のある<a href="https://reviews.llvm.org/D99149">小さめのパッチ</a>を送ったりもしました。
自分の能力を示すためにも、Issueを立てたり、PRを投げたりするのは重要だと思います。</p>
<h1 id="your-proposal-has-been-accepted">Your proposal has been accepted!</h1>
<p>May/18/2021 (JST) の深夜に、以下のメールが届きました。</p>
<blockquote class="twitter-tweet"><p lang="ja"  dir="ltr">[報告]<br>一層精進していきます。 <a  href="https://t.co/2yuJePuOYi">pic.twitter.com/2yuJePuOYi</a></p>— uint256_t (@uint256_t) <a  href="https://twitter.com/uint256_t/status/1394347867628703746?ref_src=twsrc%5Etfw">May 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js"  charset="utf-8"></script> 
<p>受験が終わった時のような気分でした。
頑張ります。</p>
<h1 id="次回予告">次回予告</h1>
<p>丁度今日の深夜にメンターの方と話すので、何か面白い話題が生まれたら書きたい。</p>
]]></content>
        </item>
        
        <item>
            <title>Play with LLVM-IR, without LLVM</title>
            <link>https://maekawatoshiki.github.io/posts/vicis/</link>
            <pubDate>Sun, 02 May 2021 22:04:08 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/vicis/</guid>
            <description>TL;DR LLVMの代替実装をRustで作っています。(ただの趣味)
これを使って LLVM-IR とじゃれ合ってみよう、という記事です。
LLVM-IRに触れる。LLVM抜きで。 インターネットで放浪してたら、このような記事を見つけました。
RustのLLVM IRでプログラム分析ことはじめ - Toshihiro YAMAGUCHI’s Diary
私はこれまでに、rustcの吐くLLVM-IRを直接見たことがほとんどありませんでした。丁度よい機会なので、LLVMの復習がてら記事と同じようなことをしようとしたのですが、ただ真似るだけでは面白くない。
そうだ、LLVMをRustで実装して、同じようなことをしよう
というわけで、趣味として LLVMをRustで再実装し始めました。(Vicisと名付けた) この記事では Vicis を使って、LLVM-IRを、LLVM抜きで触っていきます。
とりあえずプロジェクトを作る 記事の中では、モジュールに含まれる関数を列挙していました。これと同じことをやってみます。
cargo new viewer --bin # viewerというプロジェクトにします プロジェクトを作ったら、Cargo.tomlにVicisを追加しておきましょう。
... [dependencies] vicis = { path = &amp;quot;/path/to/vicis&amp;quot; } IRを読み込む Vicisは現在、LLVM Assemblyの一部にしか対応できていません。(bitcode対応など頑張ります&amp;hellip;)
src/main.rsを以下のように変更します。
use std::{env, fs::read_to_string}; use vicis::ir::module; fn main() { let args: Vec&amp;lt;String&amp;gt; = env::args().collect(); let file = &amp;amp;args[1]; let asm = read_to_string(file).expect(&amp;#34;failed to read .ll file&amp;#34;); let module = module::parse_assembly(asm.</description>
            <content type="html"><![CDATA[<h1 id="tldr">TL;DR</h1>
<p><a href="https://github.com/maekawatoshiki/vicis">LLVMの代替実装</a>をRustで作っています。(ただの趣味)</p>
<p>これを使って LLVM-IR とじゃれ合ってみよう、という記事です。</p>
<h1 id="llvm-irに触れるllvm抜きで">LLVM-IRに触れる。LLVM抜きで。</h1>
<p>インターネットで放浪してたら、このような記事を見つけました。</p>
<p><a href="https://toyamaguchi.hatenablog.com/entry/2019/12/22/080000">RustのLLVM IRでプログラム分析ことはじめ - Toshihiro YAMAGUCHI’s Diary</a></p>
<p>私はこれまでに、rustcの吐くLLVM-IRを直接見たことがほとんどありませんでした。丁度よい機会なので、LLVMの復習がてら記事と同じようなことをしようとしたのですが、ただ真似るだけでは面白くない。</p>
<p><em>そうだ、LLVMをRustで実装して、同じようなことをしよう</em></p>
<p>というわけで、趣味として <a href="https://github.com/maekawatoshiki/vicis">LLVMをRustで再実装し始めました。(Vicisと名付けた)</a>
この記事では Vicis を使って、LLVM-IRを、LLVM抜きで触っていきます。</p>
<h2 id="とりあえずプロジェクトを作る">とりあえずプロジェクトを作る</h2>
<p>記事の中では、モジュールに含まれる関数を列挙していました。これと同じことをやってみます。</p>
<pre><code>cargo new viewer --bin # viewerというプロジェクトにします
</code></pre><p>プロジェクトを作ったら、<code>Cargo.toml</code>にVicisを追加しておきましょう。</p>
<pre><code>...
[dependencies]
vicis = { path = &quot;/path/to/vicis&quot; }
</code></pre><h2 id="irを読み込む">IRを読み込む</h2>
<p>Vicisは現在、LLVM Assemblyの一部にしか対応できていません。(bitcode対応など頑張ります&hellip;)</p>
<p><code>src/main.rs</code>を以下のように変更します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::{env, fs::read_to_string};
<span style="color:#66d9ef">use</span> vicis::ir::module;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">let</span> asm <span style="color:#f92672">=</span> read_to_string(file).expect(<span style="color:#e6db74">&#34;failed to read .ll file&#34;</span>);

    <span style="color:#66d9ef">let</span> module <span style="color:#f92672">=</span> module::parse_assembly(asm.as_str()).expect(<span style="color:#e6db74">&#34;failed to parse module&#34;</span>);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, module);
}
</code></pre></div><p>これだけで、コマンドライン引数として渡した <code>*.ll</code>ファイルの中身をパースして、内部表現としての<code>Module</code>に変換できます。
さっそく動かしてみましょう。</p>
<h2 id="hello-world">Hello World</h2>
<p>RustでHello Worldを書いて、そのIRを見てましょう。<code>hello.rs</code>というファイルを用意します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// hello.rs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
	println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello world&#34;</span>)
}
</code></pre></div><p>そして、<code>rustc</code>でコンパイルします。IRを出力する点に注意。</p>
<pre><code>rustc +stable hello.rs -o hello.ll --emit llvm-ir
</code></pre><p>できあがった <code>hello.ll</code> を引数として渡してみましょう。</p>
<pre><code>cargo run hello.ll 
</code></pre><p>おそらくとっても長いIRが出力されたと思います。成功です。</p>
<h2 id="解析">解析</h2>
<p>長いIRを目grepするのは大変なので、関数名と関数の引数の数を出力するパスを作ってみます。</p>
<p><code>main.rs</code>を以下のように修正します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::{any::Any, env, fs::read_to_string};
<span style="color:#66d9ef">use</span> vicis::{
    ir::{function, module},
    pass::{AnalysisPass, PassManager},
};

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">let</span> asm <span style="color:#f92672">=</span> read_to_string(file).expect(<span style="color:#e6db74">&#34;failed to read .ll file&#34;</span>);

    <span style="color:#66d9ef">let</span> module <span style="color:#f92672">=</span> module::parse_assembly(asm.as_str()).expect(<span style="color:#e6db74">&#34;failed to parse module&#34;</span>);
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> pm <span style="color:#f92672">=</span> PassManager::new();
    pm.add_analysis(FunctionPrinterPass);
  pm.run_analyses_on_module(<span style="color:#f92672">&amp;</span>module);
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FunctionPrinterPass</span>;

<span style="color:#66d9ef">impl</span> AnalysisPass<span style="color:#f92672">&lt;</span>function::Function<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> FunctionPrinterPass {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run_on</span>(<span style="color:#f92672">&amp;</span>self, func: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">function</span>::Function, _result: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Box<span style="color:#f92672">&lt;</span>dyn Any<span style="color:#f92672">&gt;</span>) {
        println<span style="color:#f92672">!</span>(
            <span style="color:#e6db74">&#34;Visit: {} (takes {} args)&#34;</span>,
            func.name(),
            func.params().len()
        );
    }
}
</code></pre></div><p>パスマネージャとかの実装がまだまだ適当です。それはさておいて、実行すると以下のように表示されるはずです。</p>
<pre><code>Visit: _ZN3std10sys_common9backtrace28__rust_begin_short_backtrace17h2840e0051141d5fcE (takes 1 args)
Visit: _ZN3std2rt10lang_start17h2fcf2a95611b6d93E (takes 3 args)
Visit: &quot;_ZN3std2rt10lang_start28_$u7b$$u7b$closure$u7d$$u7d$17h642830c734a0a093E&quot; (takes 1 args)
Visit: _ZN3std3sys4unix7process14process_common8ExitCode6as_i3217he311503d36a1dd10E (takes 1 args)
Visit: _ZN4core3fmt9Arguments6new_v117h8a113b20b098f88cE (takes 5 args)
Visit: &quot;_ZN4core3ops8function6FnOnce40call_once$u7b$$u7b$vtable.shim$u7d$$u7d$17h32e55b47309d557aE&quot; (takes 1 args)
Visit: _ZN4core3ops8function6FnOnce9call_once17h2daf67ca1036ee98E (takes 1 args)
Visit: _ZN4core3ops8function6FnOnce9call_once17hcf10f9084cb14a26E (takes 1 args)
Visit: &quot;_ZN4core3ptr85drop_in_place$LT$std..rt..lang_start$LT$$LP$$RP$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$17h74f0928264863a31E&quot; (takes 1 args)
Visit: _ZN4core4hint9black_box17h5fe2e550e252fbc3E (takes 0 args)
Visit: &quot;_ZN54_$LT$$LP$$RP$$u20$as$u20$std..process..Termination$GT$6report17h8ac75e0172be52beE&quot; (takes 0 args)
Visit: &quot;_ZN68_$LT$std..process..ExitCode$u20$as$u20$std..process..Termination$GT$6report17h63a57c0453f08cd5E&quot; (takes 1 args)
Visit: _ZN5hello4main17h391fdbb81e062d23E (takes 0 args)
Visit: rust_eh_personality (takes 5 args)
Visit: _ZN3std2rt19lang_start_internal17hd5b67df56ca01daeE (takes 4 args)
Visit: _ZN3std2io5stdio6_print17hfdac4ecf8a146755E (takes 1 args)
Visit: main (takes 2 args)
</code></pre><p>ちゃんと関数名と引数の数が表示されました。成功です。</p>
<h1 id="終わりに">終わりに</h1>
<p>Vicisはまだまだ実装されていない機能が沢山あります。Issue&amp;PR いつでも歓迎です。</p>
]]></content>
        </item>
        
        <item>
            <title>コンパイラと私</title>
            <link>https://maekawatoshiki.github.io/posts/compilerandi/</link>
            <pubDate>Thu, 29 Apr 2021 22:42:05 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/compilerandi/</guid>
            <description>ここでは、私がどのようにして「コンパイラ」というものを認識し、そして夢中になったのかについて書いていこうと思う。
私が初めてプログラミングを体験したのは小学6年生のころだった。C言語を使って Hello World を画面（ターミナル、そのころは Windows を使っていたからコマンドプロンプトだった）に表示するという、いたって典型的な入門だった。正直あまり面白くなかったし、そもそもキーボードが打てない、ファイルをどこに保存したのかわからない、というレベルだった。
そんなレベルの私がなぜC言語を始めたかというと、もともと簡単な電子工作をしており、次はロボットを動かしたかったからである。C言語以外の言語を知らなかった私は、親に「猫でもわかるC言語プログラミング」を買ってもらい、どうにか Hello World をコンパイルできる程度の環境を構築したというわけだ。
それ以降の小学6年生の記憶はかなり曖昧だが、たしかある程度C言語を使えるようになり、Win32 APIでウィンドウを表示するサンプルが動いて喜んでいたと思う。同時に、「なぜこの英語の文章（＝プログラム）がウィンドウを表示したりできるんだ？」といった純粋な疑問も持っていた。「コンパイラ」という単語はうっすらと認識していたが、どちらかと言えば「コンパイルして実行」のような連続した語として記憶していたため、まだコンパイラというソフトウェア自体にはあまり興味を示していなかったと思う。
中学1年生になると、すっかりロボットを動かすという目標を忘れ、GUIプログラミングを楽しんでいた。 （物理的にも処理速度的にも）重たいパソコン上で Visual Studio を動かし、C言語を書いていた。F5を押せばプログラムは動いた。そこにコンパイラはなく、その存在は統合開発環境が隠蔽していた。 そのうちに HSP (Hot Soup Processor) を知り、簡単に GUI プログラミングができると興奮し、かなりの数のくだらないソフトウェアを作ったと思う。画面キャプチャ、ただファイルをゴミ箱に送るだけのソフト、画面端で常駐する電卓、円周率を計算するやつ&amp;hellip;..
そう、HSP で円周率を計算し始めたことで気づいた。HSP は遅い。C言語は速かったのに。
そのころになってようやく、世の中にはコンパイル型言語とインタプリタ型言語というものがあると知った。いや、知ったというよりは実感したと言うべきだろうか。とにかく、コンパイラというものに惹かれ始めたのは中学1年生のかなり後半だったと思う。ここから、私とコンパイラとの関係が始まったのだと思う。
最初のうちは、Ruby の VM に興味を持っていた。なぜ Ruby なのかはよく覚えていないが、おそらく英語が読めない私にとって、日本語の資料が落ちていたのは魅力的だったのだろう。YARV の内部構造を説明するサイト（たぶんこのあたり）に釘付けだった。この文章を書きながらリンク先を眺めていたが、今見ても面白い。第3回：命令ディスパッチの話は、当時は理解こそできなかったものの、こんなことができるのか！すごい！と興味津々だった。これが中学2年生の初めの話。
インタプリタやコンパイラのことを認識した以上、何らかの言語を作りたくなるのは避けられない。 （実は HSP で電卓を作っていた頃に、小さな言語のようなものは作っていたが、BASIC よりもしょぼい文法で、AST すら知らなかったためぐちゃぐちゃのコードだったと記憶している。もう手元にはコードが残っていない。そのコードが入っている80GB HDDは分解して、ディスクを手裏剣のように投げて遊んでいた。） 今手元に残っている言語処理系で、一番古いものは Lit だ。いつのまにか C++ を覚えたようで、C++ で書いてあるし、なんとご丁寧にGitHubに置いてある。 まったく思い出せないが、どうにかgitやGitHubの使い方を覚えたようである。最初のコミットは中学2年生の夏休み頃となっている。 Lit は Ruby っぽい言語で、なんと JIT コンパイルできる。初期は手動でアセンブラ（と言っても命令に対応する16進数をハードコードしているだけだが）のようなものを書いており、それを使って JIT していたようだ。結局 LLVM を導入してしまったようだが。そもそもどのような経緯でLLVMを知ったのかも思い出せない。
中学3年生になると、ほとんど理解できていなかったと思われるが、Python や Clang を読んでいたような気がする。また、中学生が終わろうとしているときに、CMake があまりにも嫌いで C++ ごと捨ててしまった。同時に Rust を本格的に使い始めた。</description>
            <content type="html"><![CDATA[<p>ここでは、私がどのようにして「コンパイラ」というものを認識し、そして夢中になったのかについて書いていこうと思う。</p>
<p>私が初めてプログラミングを体験したのは小学6年生のころだった。C言語を使って <code>Hello World</code> を画面（ターミナル、そのころは Windows を使っていたからコマンドプロンプトだった）に表示するという、いたって典型的な入門だった。正直あまり面白くなかったし、そもそもキーボードが打てない、ファイルをどこに保存したのかわからない、というレベルだった。</p>
<p>そんなレベルの私がなぜC言語を始めたかというと、もともと簡単な電子工作をしており、次はロボットを動かしたかったからである。C言語以外の言語を知らなかった私は、親に「猫でもわかるC言語プログラミング」を買ってもらい、どうにか Hello World をコンパイルできる程度の環境を構築したというわけだ。</p>
<p>それ以降の小学6年生の記憶はかなり曖昧だが、たしかある程度C言語を使えるようになり、Win32 APIでウィンドウを表示するサンプルが動いて喜んでいたと思う。同時に、「なぜこの英語の文章（＝プログラム）がウィンドウを表示したりできるんだ？」といった純粋な疑問も持っていた。「コンパイラ」という単語はうっすらと認識していたが、どちらかと言えば「コンパイルして実行」のような連続した語として記憶していたため、まだコンパイラというソフトウェア自体にはあまり興味を示していなかったと思う。</p>
<p>中学1年生になると、すっかりロボットを動かすという目標を忘れ、GUIプログラミングを楽しんでいた。
（物理的にも処理速度的にも）重たいパソコン上で Visual Studio を動かし、C言語を書いていた。F5を押せばプログラムは動いた。そこにコンパイラはなく、その存在は統合開発環境が隠蔽していた。
そのうちに HSP (Hot Soup Processor) を知り、簡単に GUI プログラミングができると興奮し、かなりの数のくだらないソフトウェアを作ったと思う。画面キャプチャ、ただファイルをゴミ箱に送るだけのソフト、画面端で常駐する電卓、円周率を計算するやつ&hellip;..</p>
<p>そう、HSP で円周率を計算し始めたことで気づいた。HSP は遅い。C言語は速かったのに。</p>
<p>そのころになってようやく、世の中にはコンパイル型言語とインタプリタ型言語というものがあると知った。いや、知ったというよりは実感したと言うべきだろうか。とにかく、コンパイラというものに惹かれ始めたのは中学1年生のかなり後半だったと思う。ここから、私とコンパイラとの関係が始まったのだと思う。</p>
<p>最初のうちは、Ruby の VM に興味を持っていた。なぜ Ruby なのかはよく覚えていないが、おそらく英語が読めない私にとって、日本語の資料が落ちていたのは魅力的だったのだろう。YARV の内部構造を説明するサイト（たぶん<a href="https://magazine.rubyist.net/articles/0007/0007-YarvManiacs.html">このあたり</a>）に釘付けだった。この文章を書きながらリンク先を眺めていたが、今見ても面白い。第3回：命令ディスパッチの話は、当時は理解こそできなかったものの、こんなことができるのか！すごい！と興味津々だった。これが中学2年生の初めの話。</p>
<p>インタプリタやコンパイラのことを認識した以上、何らかの言語を作りたくなるのは避けられない。
（実は HSP で電卓を作っていた頃に、小さな言語のようなものは作っていたが、BASIC よりもしょぼい文法で、AST すら知らなかったためぐちゃぐちゃのコードだったと記憶している。もう手元にはコードが残っていない。そのコードが入っている80GB HDDは分解して、ディスクを手裏剣のように投げて遊んでいた。）
今手元に残っている言語処理系で、一番古いものは <a href="https://github.com/maekawatoshiki/lit-x86">Lit</a> だ。いつのまにか C++ を覚えたようで、C++ で書いてあるし、なんとご丁寧にGitHubに置いてある。
まったく思い出せないが、どうにかgitやGitHubの使い方を覚えたようである。最初のコミットは中学2年生の夏休み頃となっている。
Lit は Ruby っぽい言語で、なんと JIT コンパイルできる。初期は手動でアセンブラ（と言っても命令に対応する16進数をハードコードしているだけだが）のようなものを書いており、それを使って JIT していたようだ。結局 LLVM を導入してしまったようだが。そもそもどのような経緯でLLVMを知ったのかも思い出せない。</p>
<p>中学3年生になると、ほとんど理解できていなかったと思われるが、Python や Clang を読んでいたような気がする。また、中学生が終わろうとしているときに、CMake があまりにも嫌いで C++ ごと捨ててしまった。同時に Rust を本格的に使い始めた。</p>
<p>そろそろこの文章を書くのも疲れてきた。ここからは簡潔にまとめよう。</p>
<p>高校生になると、本当に色々なことがあった。入門したての Rust でいきなり C言語のコンパイラを作ったり (8ccには本当にお世話になりました) 。 ブラウザを作ったり。JavaScript処理系を作ったり。JVMを作ったり。.NET VMを作ったり。型システムにも少しだけ詳しくなった。受験が嫌でコンパイラ基盤を作ったりもした。そうそう、<a href="https://prog-lang-sys-ja-slack.github.io/wiki/">プログラミング言語処理系が好きな人の集まり</a>というSlackワークスペースも開いた。受験期なのに地下鉄でLLVMのソースコードリーディングをしていた。</p>
<p>そして大学生になった。流行り病のことは完全に予想外だった。一年間完全にオンラインだったこともあり、家でずっとコンパイラのことを考えていられる生活ができたのは良かったかもしれない。これからもコンパイラのことを考え続けるだろう。</p>
<p>しかし、ひとつだけわからないのは、私はコンパイラの何が好きなのかということだ。ただ漠然と、好き、という感情があるだけで、それ以上何もない。
今後しばらくは、コンパイラの何に惹かれているのかを考えることになりそうだ。</p>
]]></content>
        </item>
        
        <item>
            <title>Third</title>
            <link>https://maekawatoshiki.github.io/posts/third/</link>
            <pubDate>Sun, 28 Feb 2021 23:30:39 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/third/</guid>
            <description></description>
            <content type="html"><![CDATA[]]></content>
        </item>
        
        <item>
            <title>Second</title>
            <link>https://maekawatoshiki.github.io/posts/second/</link>
            <pubDate>Sun, 28 Feb 2021 23:26:09 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/second/</guid>
            <description>my second page</description>
            <content type="html"><![CDATA[<p>my second page</p>
]]></content>
        </item>
        
        <item>
            <title>Welcome!!</title>
            <link>https://maekawatoshiki.github.io/posts/welcome/</link>
            <pubDate>Sun, 28 Feb 2021 14:00:00 +0000</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/welcome/</guid>
            <description>hello world</description>
            <content type="html"><![CDATA[<p>hello world</p>
]]></content>
        </item>
        
    </channel>
</rss>
