<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Hello</title>
        <link>https://maekawatoshiki.github.io/posts/</link>
        <description>Recent content in Posts on Hello</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja-jp</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Thu, 23 Dec 2021 19:47:09 +0900</lastBuildDate>
        <atom:link href="https://maekawatoshiki.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>DNN雑記</title>
            <link>https://maekawatoshiki.github.io/posts/ml/</link>
            <pubDate>Thu, 23 Dec 2021 19:47:09 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/ml/</guid>
            <description>この記事は何？ いきなりDeep Neural Networkの世界に足を踏み入れた人がいろいろ語るだけ あまり細かい話はしない 丸と矢印 深層学習だとかニューラルネットワーク（以下NN）だとか検索すると、以下のような画像をよく見かけると思う。全結合層があって、多分最後の方に活性化関数が挟んである。
入力にデータを流し込んであげると出力を得ることができる、とてもシンプルな構造をしている。
丸と矢印と… しかし、近年実際に使われているDNNはこれほど簡単な構造はしていない。
例えば、以下は文字認識を行うモデル(MNIST1)をONNX2形式としてエクスポートしてnetron3で表示したもの。
一目瞭然だが、先ほどの画像のNNとはだいぶ見た目が違う。丸くないし、いや、でも矢印はある。 丸の代わりに角丸の四角が現れた。矢印の横には謎の数字の列が書いてある。
ぱっと見、グラフ（DAG）であることはわかると思う。
軽く説明すると以下の通り。
角丸の四角: 命令（Operator; ONNX用語？真に受けないでほしい）。命令はデータに対してなんらかの操作を行う。 例えば、上の画像中の Relu はデータの一要素づつ（数値一つ一つ）に ReLU4 を適用する 一方、Conv はデータ全体に対して畳み込み5 を行う 命令ごとに、一要素づつ(element-wise)に操作を行なうのか、部分的に({layer,channel,row,&amp;hellip;}-wise)操作を行なうのか違ってややこしい 矢印: データの流れる方向。データというのは画像だったり文字列だったり… 謎の数字の列: テンソル6のshape。要するにデータがどのような形（のテンソル）なのかを表す。 なんと静的じゃないこともある。画像中ではすべての矢印の横に数字の列（＝shape)が書いてあるが、これは運がいいだけ。shape inference（=shapeを推論する）しても静的に shape が決まらないこともある。でもそのおかげで文字列とか複数のbounding boxを扱えたりする。 より複雑なモデル（画像を分類したりとか）は、もちろんより複雑な構造をしている。netron で表示すると重い。
グラフを計算機が理解するまで DNN はネットワークであり、グラフであり、そのままでは計算機上で動かない。
PyTorch, TensorFlow, Chainer, &amp;hellip; などの機械学習フレームワークは、設計思想の差こそあれ結局はNNモデルを計算機上で実際に動作させるためのものである。そこにはコンパイラと呼べるものが必ずある。いわゆる機械学習コンパイラである。
機械学習コンパイラのやることは、簡単に言えば以下の通りである。
NNモデルのグラフをより簡単な表現に変換する。命令（ノード）同士をくっつけたり分離したり、大胆に順番を入れ替えたり。（数学的に正しくなくてもいい！） 命令の実行順序を決定する。動的に変える場合もある。グラフ中には並列に実行できる命令が含まれるので気を付ける。 CPU, GPU, 独自アクセラレータなどごとに命令列を機械語へ変換。アセンブリを吐いたり、（サボって）LLVMとかOpenCLとかでカーネル吐いたり。CUDAで頑張る？ このあと、CPU, GPU, &amp;hellip; などが複雑に絡み合うヘテロジニアスな環境でどうやって高速にデータを受け渡すか、などの話もあるけどコンパイラの役割じゃない気がしたので省略。
現実 DNN は実際はただのグラフで、そこにデータを流し込んでるだけ。学習時はちょっと違うのかもしれないけど、少なくとも推論時はそう。
計算機をいかに高速に・効率的に動かすかを考えるのは面白い。けど、これが人工知能って呼ばれてるのをみるとなんか微妙な気持ちになるね。
（p.s. DNNの量子化の話聞きたい人いるかな？モデルのパラメータ数を減らしたり、モデル自体を小さくコンパクトにする系の話）
脚注 MNISTデータセット&amp;#160;&amp;#x21a9;&amp;#xfe0e;
Open Neural Network Exchange の略。ここでは ONNX の定める、NNのモデルを表現するためのフォーマットを指す。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
            <content type="html"><![CDATA[<h1 id="この記事は何">この記事は何？</h1>
<ul>
<li>いきなりDeep Neural Networkの世界に足を踏み入れた人がいろいろ語るだけ</li>
<li>あまり細かい話はしない</li>
</ul>
<h1 id="丸と矢印">丸と矢印</h1>
<p>深層学習だとかニューラルネットワーク（以下NN）だとか検索すると、以下のような画像をよく見かけると思う。全結合層があって、多分最後の方に活性化関数が挟んである。</p>
<p><img src="https://miro.medium.com/max/4800/1*3fA77_mLNiJTSgZFhYnU0Q.png" alt="nn"></p>
<p>入力にデータを流し込んであげると出力を得ることができる、とてもシンプルな構造をしている。</p>
<h1 id="丸と矢印と">丸と矢印と…</h1>
<p>しかし、近年実際に使われているDNNはこれほど簡単な構造はしていない。</p>
<p>例えば、以下は文字認識を行うモデル(MNIST<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>)をONNX<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>形式としてエクスポートして<code>netron</code><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>で表示したもの。</p>
<p><img src="https://cdn.thenewstack.io/media/2020/07/c601845f-onnx-mnist-0-328x1024.jpg" alt="mnist"></p>
<p>一目瞭然だが、先ほどの画像のNNとはだいぶ見た目が違う。丸くないし、いや、でも矢印はある。
丸の代わりに角丸の四角が現れた。矢印の横には謎の数字の列が書いてある。</p>
<p>ぱっと見、グラフ（DAG）であることはわかると思う。</p>
<p>軽く説明すると以下の通り。</p>
<ul>
<li>角丸の四角: <strong>命令</strong>（Operator; ONNX用語？真に受けないでほしい）。命令はデータに対してなんらかの操作を行う。
<ul>
<li>例えば、上の画像中の <code>Relu</code> はデータの一要素づつ（数値一つ一つ）に ReLU<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> を適用する</li>
<li>一方、<code>Conv</code> はデータ全体に対して畳み込み<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> を行う
<ul>
<li>命令ごとに、一要素づつ(element-wise)に操作を行なうのか、部分的に({layer,channel,row,&hellip;}-wise)操作を行なうのか違ってややこしい</li>
</ul>
</li>
</ul>
</li>
<li>矢印: データの流れる方向。データというのは画像だったり文字列だったり…</li>
<li>謎の数字の列: テンソル<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>のshape。要するにデータがどのような形（のテンソル）なのかを表す。
<ul>
<li>なんと静的じゃないこともある。画像中ではすべての矢印の横に数字の列（＝shape)が書いてあるが、これは運がいいだけ。shape inference（=shapeを推論する）しても静的に shape が決まらないこともある。でもそのおかげで文字列とか複数のbounding boxを扱えたりする。</li>
</ul>
</li>
</ul>
<p>より複雑なモデル（画像を分類したりとか）は、もちろんより複雑な構造をしている。netron で表示すると重い。</p>
<h1 id="グラフを計算機が理解するまで">グラフを計算機が理解するまで</h1>
<p>DNN はネットワークであり、グラフであり、そのままでは計算機上で動かない。</p>
<p>PyTorch, TensorFlow, Chainer, &hellip; などの機械学習フレームワークは、設計思想の差こそあれ結局はNNモデルを計算機上で実際に動作させるためのものである。そこにはコンパイラと呼べるものが必ずある。いわゆる機械学習コンパイラである。</p>
<p>機械学習コンパイラのやることは、簡単に言えば以下の通りである。</p>
<ol>
<li>NNモデルのグラフをより簡単な表現に変換する。命令（ノード）同士をくっつけたり分離したり、大胆に順番を入れ替えたり。（数学的に正しくなくてもいい！）</li>
<li>命令の実行順序を決定する。動的に変える場合もある。グラフ中には並列に実行できる命令が含まれるので気を付ける。</li>
<li>CPU, GPU, 独自アクセラレータなどごとに命令列を機械語へ変換。アセンブリを吐いたり、（サボって）LLVMとかOpenCLとかでカーネル吐いたり。CUDAで頑張る？</li>
</ol>
<p>このあと、CPU, GPU, &hellip; などが複雑に絡み合うヘテロジニアスな環境でどうやって高速にデータを受け渡すか、などの話もあるけどコンパイラの役割じゃない気がしたので省略。</p>
<h1 id="現実">現実</h1>
<p>DNN は実際はただのグラフで、そこにデータを流し込んでるだけ。学習時はちょっと違うのかもしれないけど、少なくとも推論時はそう。</p>
<p>計算機をいかに高速に・効率的に動かすかを考えるのは面白い。けど、これが人工知能って呼ばれてるのをみるとなんか微妙な気持ちになるね。</p>
<p>（p.s. DNNの量子化の話聞きたい人いるかな？モデルのパラメータ数を減らしたり、モデル自体を小さくコンパクトにする系の話）</p>
<h1 id="脚注">脚注</h1>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://ja.wikipedia.org/wiki/MNIST%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9">MNISTデータセット</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://onnx.ai/">Open Neural Network Exchange</a> の略。ここでは ONNX の定める、NNのモデルを表現するためのフォーマットを指す。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://github.com/lutzroeder/netron">netron</a>。NNのモデルを可視化してくれる。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E5%8C%96%E7%B7%9A%E5%BD%A2%E9%96%A2%E6%95%B0">ReLU</a>。角が尖ってる。&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><a href="https://ja.wikipedia.org/wiki/%E7%95%B3%E3%81%BF%E8%BE%BC%E3%81%BF%E3%83%8B%E3%83%A5%E3%83%BC%E3%83%A9%E3%83%AB%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF">Convolution</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>行列は2階のテンソル。要するに高次元の行列だと思えばわかりやすい。 <a href="https://qiita.com/enoughspacefor/items/66982f595e2c71502062#%E8%B3%87%E6%96%993tensor">これがわかりやすい？</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content>
        </item>
        
        <item>
            <title>Google Summer of Code 2021 を終えました</title>
            <link>https://maekawatoshiki.github.io/posts/gsoc3/</link>
            <pubDate>Thu, 09 Sep 2021 00:08:57 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/gsoc3/</guid>
            <description>TL;DR Google Summer of Code 2021 を終えました First, Final Evaluation ともに通りました、という意味 LLVM むずかしい 成果 Google Summer of Code とは 前に書いた記事を参照してください。
何をしたのか 2021/May/20 から 2021/Aug/28 くらいまで、メンターの方たちと共に LLVM へ貢献していました。 （まだマージされていないパッチがあるんですけどね&amp;hellip;）
正確には、コーディングをはじめたのは６月くらいからみたいです。
LLVM? The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. The LLVM Compiler Infrastructure
clang や lld などを傘下に持つ、コンパイラ基盤のプロジェクトです。
（以下 LLVM についてある程度詳しいことを前提として話を進めていきます；またいつか LLVM 自体の解説もしたい）
テーマ 提出した Proposal のタイトルは Utilize LoopNest Pass でした。
Pass というと、Module Pass, Function Pass, Loop Pass, &amp;hellip; など色々あります。 その中に、最近追加されたばかりの LoopNest Pass (New Pass Manager でのみ動作) というものがあります。 これは、ネストしたループを扱うための Pass なのですが、 まだほとんど使われていません（でした）。 私がこの夏にやったことは、LoopNest Pass として実装されている Pass を増やすことです。</description>
            <content type="html"><![CDATA[<h1 id="tldr">TL;DR</h1>
<ul>
<li>Google Summer of Code 2021 を終えました
<ul>
<li>First, Final Evaluation ともに通りました、という意味</li>
</ul>
</li>
<li>LLVM むずかしい</li>
<li><a href="https://docs.google.com/document/d/1ASGejJIL7rzEDwX2qZZqT4ATR2x3sd_aOTuMSCh2YTE/edit#heading=h.qv3zfxev18ag">成果</a></li>
</ul>
<h1 id="google-summer-of-code-とは">Google Summer of Code とは</h1>
<p><a href="../gsoc1">前に書いた記事</a>を参照してください。</p>
<h1 id="何をしたのか">何をしたのか</h1>
<p>2021/May/20 から 2021/Aug/28 くらいまで、メンターの方たちと共に LLVM へ貢献していました。
（まだマージされていないパッチがあるんですけどね&hellip;）</p>
<p>正確には、コーディングをはじめたのは６月くらいからみたいです。</p>
<h1 id="llvm">LLVM?</h1>
<blockquote>
<p>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.
<a href="https://llvm.org/">The LLVM Compiler Infrastructure</a></p>
</blockquote>
<p>clang や lld などを傘下に持つ、コンパイラ基盤のプロジェクトです。</p>
<p>（以下 LLVM についてある程度詳しいことを前提として話を進めていきます；またいつか LLVM 自体の解説もしたい）</p>
<h1 id="テーマ">テーマ</h1>
<p>提出した Proposal のタイトルは <strong>Utilize LoopNest Pass</strong> でした。</p>
<p>Pass というと、Module Pass, Function Pass, Loop Pass, &hellip; など色々あります。
その中に、最近追加されたばかりの <strong>LoopNest Pass</strong> (New Pass Manager でのみ動作) というものがあります。
これは、ネストしたループを扱うための Pass なのですが、
まだほとんど使われていません（でした）。
私がこの夏にやったことは、LoopNest Pass として実装されている Pass を増やすことです。</p>
<p>Loop Pass とは別に LoopNest Pass が作られた理由にはいくつかあります。
例えば、ネストしたループ向けの最適化手法には、Loop Pass (や Function Pass) として実装するとコード量が増えてしまうものや、そもそも
うまく実装できないものが存在します。そのような最適化手法は、LoopNest Pass として簡単に実装できる可能性が高いです。</p>
<h2 id="loopnest-pass-と-loop-pass-の違い">LoopNest Pass と Loop Pass の違い</h2>
<p>Loop Pass Pipeline <em>X</em> に、Loop Pass <em>A, B</em> が順番に並んでいるとします。
ここで、<em>X</em> に以下のループを流してみます。（<em>X</em> に <code>outerL</code> に対応する <code>Loop</code> オブジェクトを渡す、の意）</p>
<pre tabindex="0"><code>outerL:
  innerL:
    body
</code></pre><p>すると、まず <code>innerL</code> が <em>A, B</em> によって最適化され、その後に <code>outerL</code> が <em>A, B</em> によって最適化されます。
要するに、最内ループから最外ループへ向かって最適化が行われるというわけです。</p>
<p>特に問題なさそうに見えますが、これはあくまで個別のループに個別の最適化を施す場合には問題がない、というだけです。</p>
<p>例えば、<code>outerL</code> と <code>innerL</code> を見比べてからループネスト全体に何らかの操作を施したい場合はどうしればいいのでしょうか。
（単純な解決法：<code>innerL</code> を無視して <code>outerL</code> の順番がやってきたらループネスト全体を見渡せば良い；
問題：<code>innerL</code> を飛ばすためのコードが必要になる。そもそも Loop Pass に渡される <code>Loop</code> オブジェクトはループネストを扱うのには適していない）</p>
<p>ここで LoopNest Pass の登場です。</p>
<p>Loop Pass Pipeline <em>Y</em> に、Loop Pass <em>A, B</em> と LoopNest Pass <em>C</em> が順番に並んでいるとします。
ここで、<em>Y</em> に先程のループを流してみます。</p>
<p>すると、まず <code>innerL</code> が <em>A, B</em> によって最適化され、その後に <code>outerL</code> が <em>A, B, <strong>C</strong></em> によって最適化されます。
要するに、<strong>LoopNest Pass は最外ループにのみ適用される</strong>のです。
しかも、LoopNest Pass は <code>Loop</code> オブジェクトではなく <code>LoopNest</code> オブジェクトを受けとります。
これにより、Loop Pass として実装する場合と比べて、ループネストを扱いやすくなります。</p>
<h2 id="もうちょっと具体例-loop-interchange">もうちょっと具体例: loop-interchange</h2>
<p>以下のようなループネストを考えます。</p>
<pre tabindex="0"><code>for k = 0, 10:
  for i = 0, 10:
    for j = 0, 10:
      A[i, j, k] += B[i, j, k]
</code></pre><p>見るからに何かがおかしいですよね？最外ループの添字が <code>k</code> となっていますが、これではキャッシュに当たる気がしません。</p>
<p>このようなループネストには、それぞれのループの順番を入れ替える loop-interchange という最適化を施すと良いです。</p>
<pre tabindex="0"><code># loop-interchange 後
for i = 0, 10:
  for j = 0, 10:
    for k = 0, 10:
      A[i, j, k] += B[i, j, k]
</code></pre><p>このような最適化は、ループネスト全体を見渡す必要があります。そのため LoopNest Pass として実装すると良いです。
（でないと、for-k を飛ばして・for-j を飛ばして、という処理を個々の Loop Pass 内に記述する必要が出てきます）</p>
<h1 id="何を学んだのか">何を学んだのか</h1>
<p>LLVM という大きな OSS プロジェクトに貢献する中で、色々なことを学びました。</p>
<p>例えば、私はいつも大きなソースツリーを見ると上から下まで読みたくなるのですが、
そんなことを LLVM に対してしていたら一生が終わってしまいます。
なので今回の GSoC ではそんなことはせず、自分の担当する部分に関連する部分だけを集中的に読みました。
大きなソフトウェアはその一部分のみを理解しているだけで十分（であることが望ましい…）なんだと実感しました。</p>
<p>もう一つ、痛感したことがあります。
それは、コーディング能力は確かに重要だけれども、それ以上にコミュニケーション能力が重要だということです。
パッチを投げる、レビューを受ける、変更の意図を説明する…、すべての過程で（英語での）わかりやすい説明を求められます。
自分の意図を正確に伝えられないと、相手に無駄な時間を取らせてしまうこともあります。</p>
<p>英語でのテキスト（&amp;できれば口頭での）コミュニケーション能力は身につけておかないと痛い目に合います。</p>
<h1 id="どうでもいいこと一覧">どうでもいいこと一覧</h1>
<ul>
<li>メンター２人（１人とはあんまり話さなかったけど）、プロジェクトメンバー２人、私の合計５人でプロジェクトを進めた
<ul>
<li>私とプロジェクトメンバーの１人がほとんどのパッチを作ったと思う</li>
</ul>
</li>
<li>連絡は Discord で行った</li>
<li>毎週 Webex でミーティングを行った。口頭での英語にほんの少しだけ慣れた。</li>
<li>LLVM のコミット権をもらえて嬉しかった</li>
<li>2700USD 貰った （<a href="https://developers.google.com/open-source/gsoc/help/student-stipends">国ごとに貰える量は違うみたい</a>）</li>
<li>お金は <a href="https://www.payoneer.com/ja/">Payoneer</a>ってやつで受け取った</li>
<li>CI が落ちると怖い（メールが来る）</li>
<li>Address/Memory Sanitizer は偉い</li>
<li>初めて master にコミットしたときは手が震えた
<ul>
<li>そしてそのコミットを何度も revert する羽目になって辛かった</li>
</ul>
</li>
</ul>
<p>以上。来年以降に参加する人の助けになればいいなあ。</p>
<p>（質問があれば twitter@uint256_t へ DM とか投げてください）</p>
]]></content>
        </item>
        
        <item>
            <title>GSoC 2021 の First Evaluation に通りました</title>
            <link>https://maekawatoshiki.github.io/posts/gsoc2/</link>
            <pubDate>Sun, 25 Jul 2021 01:16:16 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/gsoc2/</guid>
            <description>TL;DR Google Summer of Code 2021 の First Evaluation に通りました 2700USD * 0.45 = 1215USD = 13万円くらい貰えました 詳しいこと あとで書きます</description>
            <content type="html"><![CDATA[<h1 id="tldr">TL;DR</h1>
<ul>
<li>Google Summer of Code 2021 の First Evaluation に通りました</li>
<li>2700USD * 0.45 = 1215USD = 13万円くらい貰えました</li>
</ul>
<h1 id="詳しいこと">詳しいこと</h1>
<p>あとで書きます</p>
]]></content>
        </item>
        
        <item>
            <title>Google Summer of Code 2021 に参加します</title>
            <link>https://maekawatoshiki.github.io/posts/gsoc1/</link>
            <pubDate>Wed, 19 May 2021 15:56:20 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/gsoc1/</guid>
            <description>TL;DR Google Summer of Code に提出したProposalが採択されました 晴れてGSoCに参加できることとなりました 参加団体はLLVMです 嬉しい Google Summer of Codeとは Google Summer of Code is a global program focused on bringing more student developers into open source software development. Students work with an open source organization on a 10 week programming project during their break from school.
(https://summerofcode.withgoogle.com/)
Google Summer of Code は、OSSプロジェクトにメンター付きで参加することができ、さらに Google から報酬ももらえるイベントです。 その名の通り夏（休み）に行われるのですが、アメリカ規準であって、日本の大学などでは普通に授業が行われています。 本来であれば、学部2年生の私にとっては参加が少し厳しいはずでしたが、今年は新型コロナの影響でプロジェクトに取り組む時間の制約が緩くなった (40h/w→17h+/w) ので、思い切って参加してみました。(大学もずっとオンラインで、家にこもりっぱなしですし。)
Proposal採択までの流れ 3月の初めから、以下の作業を始めました。
参加団体を選ぶ 公式サイトを見れば、様々な団体がGSoCに参加しているとわかります。 私は、ずっと LLVM に貢献したかったので、無論それを選びました。
参加プロジェクトを選ぶ 各団体のほぼすべてが、学生向けのプロジェクト一覧を公開しているはずです。LLVM ならここ。 興味のあるプロジェクトは、初めのうちは複数個選んでおいた方がいいと思います。後になって、選んだプロジェクトが想像以上に難しいものだと判明すると、Proposalを書くのが大変ですし、不必要に自分を追い込んでしまいます。</description>
            <content type="html"><![CDATA[<h1 id="tldr">TL;DR</h1>
<ul>
<li>Google Summer of Code に提出したProposalが採択されました</li>
<li>晴れてGSoCに参加できることとなりました</li>
<li>参加団体はLLVMです</li>
<li>嬉しい</li>
</ul>
<h1 id="google-summer-of-codeとは">Google Summer of Codeとは</h1>
<blockquote>
<p>Google Summer of Code is a global program focused on bringing more  student developers into open source software development. Students work  with an open source organization on a 10 week programming project during their break from school.</p>
<p>(<a href="https://summerofcode.withgoogle.com/">https://summerofcode.withgoogle.com/</a>)</p>
</blockquote>
<p>Google Summer of Code は、OSSプロジェクトにメンター付きで参加することができ、さらに Google から報酬ももらえるイベントです。
その名の通り夏（休み）に行われるのですが、アメリカ規準であって、日本の大学などでは普通に授業が行われています。
本来であれば、学部2年生の私にとっては参加が少し厳しいはずでしたが、今年は新型コロナの影響でプロジェクトに取り組む時間の制約が緩くなった (40h/w→17h+/w) ので、思い切って参加してみました。(大学もずっとオンラインで、家にこもりっぱなしですし。)</p>
<h1 id="proposal採択までの流れ">Proposal採択までの流れ</h1>
<p>3月の初めから、以下の作業を始めました。</p>
<h2 id="参加団体を選ぶ">参加団体を選ぶ</h2>
<p><a href="https://summerofcode.withgoogle.com/organizations/">公式サイト</a>を見れば、様々な団体がGSoCに参加しているとわかります。
私は、ずっと <a href="https://llvm.org/">LLVM</a> に貢献したかったので、無論それを選びました。</p>
<h2 id="参加プロジェクトを選ぶ">参加プロジェクトを選ぶ</h2>
<p>各団体のほぼすべてが、学生向けのプロジェクト一覧を公開しているはずです。LLVM なら<a href="https://llvm.org/OpenProjects.html">ここ</a>。
興味のあるプロジェクトは、初めのうちは複数個選んでおいた方がいいと思います。後になって、選んだプロジェクトが想像以上に難しいものだと判明すると、Proposalを書くのが大変ですし、不必要に自分を追い込んでしまいます。</p>
<h2 id="メーリングリストと奮闘する">メーリングリストと奮闘する</h2>
<p>興味のあるプロジェクトを選んだら、各団体のメンターと連絡を取ります。ここから先は各団体の指示に従うべきです。
私の場合は、メーリングリストでメンターの方にプロジェクトの詳しい説明を聞いていました。<a href="https://lists.llvm.org/pipermail/llvm-dev/2021-March/149058.html">このあたり</a>から辿れます。</p>
<p>(英語のメールを書くのがかなり久しぶりだったので少し緊張しました。)</p>
<h2 id="proposalを書く">Proposalを書く</h2>
<p>各団体に提出するためのProposalを書きます。ネット上には過去GSoCに参加した方のProposalの例が沢山公開されています。</p>
<p><a href="https://docs.google.com/document/d/1UhKyBsVCwuN7VCbaQRVdklY9CCsGM04EcvhLHO0A-UQ/edit?usp=sharing">もちろん私も公開します。</a></p>
<p>Proposalは、ある程度書いたらメンターの人に見てもらって、アドバイスを貰ったりしました。</p>
<h2 id="と同時並行で-小さめのパッチを送る">(↑と同時並行で) 小さめのパッチを送る</h2>
<p>Proposalの内容と関係のある<a href="https://reviews.llvm.org/D99149">小さめのパッチ</a>を送ったりもしました。
自分の能力を示すためにも、Issueを立てたり、PRを投げたりするのは重要だと思います。</p>
<h1 id="your-proposal-has-been-accepted">Your proposal has been accepted!</h1>
<p>May/18/2021 (JST) の深夜に、以下のメールが届きました。</p>
<blockquote class="twitter-tweet"><p lang="ja"  dir="ltr">[報告]<br>一層精進していきます。 <a  href="https://t.co/2yuJePuOYi">pic.twitter.com/2yuJePuOYi</a></p>— uint256_t (@uint256_t) <a  href="https://twitter.com/uint256_t/status/1394347867628703746?ref_src=twsrc%5Etfw">May 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js"  charset="utf-8"></script> 
<p>受験が終わった時のような気分でした。
頑張ります。</p>
<h1 id="次回予告">次回予告</h1>
<p>丁度今日の深夜にメンターの方と話すので、何か面白い話題が生まれたら書きたい。</p>
]]></content>
        </item>
        
        <item>
            <title>Play with LLVM-IR, without LLVM</title>
            <link>https://maekawatoshiki.github.io/posts/vicis/</link>
            <pubDate>Sun, 02 May 2021 22:04:08 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/vicis/</guid>
            <description>TL;DR LLVMの代替実装をRustで作っています。(ただの趣味)
これを使って LLVM-IR とじゃれ合ってみよう、という記事です。
LLVM-IRに触れる。LLVM抜きで。 インターネットで放浪してたら、このような記事を見つけました。
RustのLLVM IRでプログラム分析ことはじめ - Toshihiro YAMAGUCHI’s Diary
私はこれまでに、rustcの吐くLLVM-IRを直接見たことがほとんどありませんでした。丁度よい機会なので、LLVMの復習がてら記事と同じようなことをしようとしたのですが、ただ真似るだけでは面白くない。
そうだ、LLVMをRustで実装して、同じようなことをしよう
というわけで、趣味として LLVMをRustで再実装し始めました。(Vicisと名付けた) この記事では Vicis を使って、LLVM-IRを、LLVM抜きで触っていきます。
とりあえずプロジェクトを作る 記事の中では、モジュールに含まれる関数を列挙していました。これと同じことをやってみます。
cargo new viewer --bin # viewerというプロジェクトにします プロジェクトを作ったら、Cargo.tomlにVicisを追加しておきましょう。
... [dependencies] vicis = { path = &amp;#34;/path/to/vicis&amp;#34; } IRを読み込む Vicisは現在、LLVM Assemblyの一部にしか対応できていません。(bitcode対応など頑張ります&amp;hellip;)
src/main.rsを以下のように変更します。
use std::{env, fs::read_to_string}; use vicis::ir::module; fn main() { let args: Vec&amp;lt;String&amp;gt; = env::args().collect(); let file = &amp;amp;args[1]; let asm = read_to_string(file).expect(&amp;#34;failed to read .ll file&amp;#34;); let module = module::parse_assembly(asm.</description>
            <content type="html"><![CDATA[<h1 id="tldr">TL;DR</h1>
<p><a href="https://github.com/maekawatoshiki/vicis">LLVMの代替実装</a>をRustで作っています。(ただの趣味)</p>
<p>これを使って LLVM-IR とじゃれ合ってみよう、という記事です。</p>
<h1 id="llvm-irに触れるllvm抜きで">LLVM-IRに触れる。LLVM抜きで。</h1>
<p>インターネットで放浪してたら、このような記事を見つけました。</p>
<p><a href="https://toyamaguchi.hatenablog.com/entry/2019/12/22/080000">RustのLLVM IRでプログラム分析ことはじめ - Toshihiro YAMAGUCHI’s Diary</a></p>
<p>私はこれまでに、rustcの吐くLLVM-IRを直接見たことがほとんどありませんでした。丁度よい機会なので、LLVMの復習がてら記事と同じようなことをしようとしたのですが、ただ真似るだけでは面白くない。</p>
<p><em>そうだ、LLVMをRustで実装して、同じようなことをしよう</em></p>
<p>というわけで、趣味として <a href="https://github.com/maekawatoshiki/vicis">LLVMをRustで再実装し始めました。(Vicisと名付けた)</a>
この記事では Vicis を使って、LLVM-IRを、LLVM抜きで触っていきます。</p>
<h2 id="とりあえずプロジェクトを作る">とりあえずプロジェクトを作る</h2>
<p>記事の中では、モジュールに含まれる関数を列挙していました。これと同じことをやってみます。</p>
<pre tabindex="0"><code>cargo new viewer --bin # viewerというプロジェクトにします
</code></pre><p>プロジェクトを作ったら、<code>Cargo.toml</code>にVicisを追加しておきましょう。</p>
<pre tabindex="0"><code>...
[dependencies]
vicis = { path = &#34;/path/to/vicis&#34; }
</code></pre><h2 id="irを読み込む">IRを読み込む</h2>
<p>Vicisは現在、LLVM Assemblyの一部にしか対応できていません。(bitcode対応など頑張ります&hellip;)</p>
<p><code>src/main.rs</code>を以下のように変更します。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{env, fs::read_to_string};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> vicis::ir::module;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> asm <span style="color:#f92672">=</span> read_to_string(file).expect(<span style="color:#e6db74">&#34;failed to read .ll file&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> module <span style="color:#f92672">=</span> module::parse_assembly(asm.as_str()).expect(<span style="color:#e6db74">&#34;failed to parse module&#34;</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, module);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>これだけで、コマンドライン引数として渡した <code>*.ll</code>ファイルの中身をパースして、内部表現としての<code>Module</code>に変換できます。
さっそく動かしてみましょう。</p>
<h2 id="hello-world">Hello World</h2>
<p>RustでHello Worldを書いて、そのIRを見てましょう。<code>hello.rs</code>というファイルを用意します。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// hello.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	println!(<span style="color:#e6db74">&#34;hello world&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>そして、<code>rustc</code>でコンパイルします。IRを出力する点に注意。</p>
<pre tabindex="0"><code>rustc +stable hello.rs -o hello.ll --emit llvm-ir
</code></pre><p>できあがった <code>hello.ll</code> を引数として渡してみましょう。</p>
<pre tabindex="0"><code>cargo run hello.ll 
</code></pre><p>おそらくとっても長いIRが出力されたと思います。成功です。</p>
<h2 id="解析">解析</h2>
<p>長いIRを目grepするのは大変なので、関数名と関数の引数の数を出力するパスを作ってみます。</p>
<p><code>main.rs</code>を以下のように修正します。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{any::Any, env, fs::read_to_string};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> vicis::{
</span></span><span style="display:flex;"><span>    ir::{function, module},
</span></span><span style="display:flex;"><span>    pass::{AnalysisPass, PassManager},
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> asm <span style="color:#f92672">=</span> read_to_string(file).expect(<span style="color:#e6db74">&#34;failed to read .ll file&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> module <span style="color:#f92672">=</span> module::parse_assembly(asm.as_str()).expect(<span style="color:#e6db74">&#34;failed to parse module&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> pm <span style="color:#f92672">=</span> PassManager::new();
</span></span><span style="display:flex;"><span>    pm.add_analysis(FunctionPrinterPass);
</span></span><span style="display:flex;"><span>  pm.run_analyses_on_module(<span style="color:#f92672">&amp;</span>module);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FunctionPrinterPass</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> AnalysisPass<span style="color:#f92672">&lt;</span>function::Function<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> FunctionPrinterPass {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run_on</span>(<span style="color:#f92672">&amp;</span>self, func: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">function</span>::Function, _result: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Any<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>        println!(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Visit: {} (takes {} args)&#34;</span>,
</span></span><span style="display:flex;"><span>            func.name(),
</span></span><span style="display:flex;"><span>            func.params().len()
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>パスマネージャとかの実装がまだまだ適当です。それはさておいて、実行すると以下のように表示されるはずです。</p>
<pre tabindex="0"><code>Visit: _ZN3std10sys_common9backtrace28__rust_begin_short_backtrace17h2840e0051141d5fcE (takes 1 args)
Visit: _ZN3std2rt10lang_start17h2fcf2a95611b6d93E (takes 3 args)
Visit: &#34;_ZN3std2rt10lang_start28_$u7b$$u7b$closure$u7d$$u7d$17h642830c734a0a093E&#34; (takes 1 args)
Visit: _ZN3std3sys4unix7process14process_common8ExitCode6as_i3217he311503d36a1dd10E (takes 1 args)
Visit: _ZN4core3fmt9Arguments6new_v117h8a113b20b098f88cE (takes 5 args)
Visit: &#34;_ZN4core3ops8function6FnOnce40call_once$u7b$$u7b$vtable.shim$u7d$$u7d$17h32e55b47309d557aE&#34; (takes 1 args)
Visit: _ZN4core3ops8function6FnOnce9call_once17h2daf67ca1036ee98E (takes 1 args)
Visit: _ZN4core3ops8function6FnOnce9call_once17hcf10f9084cb14a26E (takes 1 args)
Visit: &#34;_ZN4core3ptr85drop_in_place$LT$std..rt..lang_start$LT$$LP$$RP$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$17h74f0928264863a31E&#34; (takes 1 args)
Visit: _ZN4core4hint9black_box17h5fe2e550e252fbc3E (takes 0 args)
Visit: &#34;_ZN54_$LT$$LP$$RP$$u20$as$u20$std..process..Termination$GT$6report17h8ac75e0172be52beE&#34; (takes 0 args)
Visit: &#34;_ZN68_$LT$std..process..ExitCode$u20$as$u20$std..process..Termination$GT$6report17h63a57c0453f08cd5E&#34; (takes 1 args)
Visit: _ZN5hello4main17h391fdbb81e062d23E (takes 0 args)
Visit: rust_eh_personality (takes 5 args)
Visit: _ZN3std2rt19lang_start_internal17hd5b67df56ca01daeE (takes 4 args)
Visit: _ZN3std2io5stdio6_print17hfdac4ecf8a146755E (takes 1 args)
Visit: main (takes 2 args)
</code></pre><p>ちゃんと関数名と引数の数が表示されました。成功です。</p>
<h1 id="終わりに">終わりに</h1>
<p>Vicisはまだまだ実装されていない機能が沢山あります。Issue&amp;PR いつでも歓迎です。</p>
]]></content>
        </item>
        
        <item>
            <title>コンパイラと私</title>
            <link>https://maekawatoshiki.github.io/posts/compilerandi/</link>
            <pubDate>Thu, 29 Apr 2021 22:42:05 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/compilerandi/</guid>
            <description>ここでは、私がどのようにして「コンパイラ」というものを認識し、そして夢中になったのかについて書いていこうと思う。
私が初めてプログラミングを体験したのは小学6年生のころだった。C言語を使って Hello World を画面（ターミナル、そのころは Windows を使っていたからコマンドプロンプトだった）に表示するという、いたって典型的な入門だった。正直あまり面白くなかったし、そもそもキーボードが打てない、ファイルをどこに保存したのかわからない、というレベルだった。
そんなレベルの私がなぜC言語を始めたかというと、もともと簡単な電子工作をしており、次はロボットを動かしたかったからである。C言語以外の言語を知らなかった私は、親に「猫でもわかるC言語プログラミング」を買ってもらい、どうにか Hello World をコンパイルできる程度の環境を構築したというわけだ。
それ以降の小学6年生の記憶はかなり曖昧だが、たしかある程度C言語を使えるようになり、Win32 APIでウィンドウを表示するサンプルが動いて喜んでいたと思う。同時に、「なぜこの英語の文章（＝プログラム）がウィンドウを表示したりできるんだ？」といった純粋な疑問も持っていた。「コンパイラ」という単語はうっすらと認識していたが、どちらかと言えば「コンパイルして実行」のような連続した語として記憶していたため、まだコンパイラというソフトウェア自体にはあまり興味を示していなかったと思う。
中学1年生になると、すっかりロボットを動かすという目標を忘れ、GUIプログラミングを楽しんでいた。 （物理的にも処理速度的にも）重たいパソコン上で Visual Studio を動かし、C言語を書いていた。F5を押せばプログラムは動いた。そこにコンパイラはなく、その存在は統合開発環境が隠蔽していた。 そのうちに HSP (Hot Soup Processor) を知り、簡単に GUI プログラミングができると興奮し、かなりの数のくだらないソフトウェアを作ったと思う。画面キャプチャ、ただファイルをゴミ箱に送るだけのソフト、画面端で常駐する電卓、円周率を計算するやつ&amp;hellip;..
そう、HSP で円周率を計算し始めたことで気づいた。HSP は遅い。C言語は速かったのに。
そのころになってようやく、世の中にはコンパイル型言語とインタプリタ型言語というものがあると知った。いや、知ったというよりは実感したと言うべきだろうか。とにかく、コンパイラというものに惹かれ始めたのは中学1年生のかなり後半だったと思う。ここから、私とコンパイラとの関係が始まったのだと思う。
最初のうちは、Ruby の VM に興味を持っていた。なぜ Ruby なのかはよく覚えていないが、おそらく英語が読めない私にとって、日本語の資料が落ちていたのは魅力的だったのだろう。YARV の内部構造を説明するサイト（たぶんこのあたり）に釘付けだった。この文章を書きながらリンク先を眺めていたが、今見ても面白い。第3回：命令ディスパッチの話は、当時は理解こそできなかったものの、こんなことができるのか！すごい！と興味津々だった。これが中学2年生の初めの話。
インタプリタやコンパイラのことを認識した以上、何らかの言語を作りたくなるのは避けられない。 （実は HSP で電卓を作っていた頃に、小さな言語のようなものは作っていたが、BASIC よりもしょぼい文法で、AST すら知らなかったためぐちゃぐちゃのコードだったと記憶している。もう手元にはコードが残っていない。そのコードが入っている80GB HDDは分解して、ディスクを手裏剣のように投げて遊んでいた。） 今手元に残っている言語処理系で、一番古いものは Lit だ。いつのまにか C++ を覚えたようで、C++ で書いてあるし、なんとご丁寧にGitHubに置いてある。 まったく思い出せないが、どうにかgitやGitHubの使い方を覚えたようである。最初のコミットは中学2年生の夏休み頃となっている。 Lit は Ruby っぽい言語で、なんと JIT コンパイルできる。初期は手動でアセンブラ（と言っても命令に対応する16進数をハードコードしているだけだが）のようなものを書いており、それを使って JIT していたようだ。結局 LLVM を導入してしまったようだが。そもそもどのような経緯でLLVMを知ったのかも思い出せない。
中学3年生になると、ほとんど理解できていなかったと思われるが、Python や Clang を読んでいたような気がする。また、中学生が終わろうとしているときに、CMake があまりにも嫌いで C++ ごと捨ててしまった。同時に Rust を本格的に使い始めた。</description>
            <content type="html"><![CDATA[<p>ここでは、私がどのようにして「コンパイラ」というものを認識し、そして夢中になったのかについて書いていこうと思う。</p>
<p>私が初めてプログラミングを体験したのは小学6年生のころだった。C言語を使って <code>Hello World</code> を画面（ターミナル、そのころは Windows を使っていたからコマンドプロンプトだった）に表示するという、いたって典型的な入門だった。正直あまり面白くなかったし、そもそもキーボードが打てない、ファイルをどこに保存したのかわからない、というレベルだった。</p>
<p>そんなレベルの私がなぜC言語を始めたかというと、もともと簡単な電子工作をしており、次はロボットを動かしたかったからである。C言語以外の言語を知らなかった私は、親に「猫でもわかるC言語プログラミング」を買ってもらい、どうにか Hello World をコンパイルできる程度の環境を構築したというわけだ。</p>
<p>それ以降の小学6年生の記憶はかなり曖昧だが、たしかある程度C言語を使えるようになり、Win32 APIでウィンドウを表示するサンプルが動いて喜んでいたと思う。同時に、「なぜこの英語の文章（＝プログラム）がウィンドウを表示したりできるんだ？」といった純粋な疑問も持っていた。「コンパイラ」という単語はうっすらと認識していたが、どちらかと言えば「コンパイルして実行」のような連続した語として記憶していたため、まだコンパイラというソフトウェア自体にはあまり興味を示していなかったと思う。</p>
<p>中学1年生になると、すっかりロボットを動かすという目標を忘れ、GUIプログラミングを楽しんでいた。
（物理的にも処理速度的にも）重たいパソコン上で Visual Studio を動かし、C言語を書いていた。F5を押せばプログラムは動いた。そこにコンパイラはなく、その存在は統合開発環境が隠蔽していた。
そのうちに HSP (Hot Soup Processor) を知り、簡単に GUI プログラミングができると興奮し、かなりの数のくだらないソフトウェアを作ったと思う。画面キャプチャ、ただファイルをゴミ箱に送るだけのソフト、画面端で常駐する電卓、円周率を計算するやつ&hellip;..</p>
<p>そう、HSP で円周率を計算し始めたことで気づいた。HSP は遅い。C言語は速かったのに。</p>
<p>そのころになってようやく、世の中にはコンパイル型言語とインタプリタ型言語というものがあると知った。いや、知ったというよりは実感したと言うべきだろうか。とにかく、コンパイラというものに惹かれ始めたのは中学1年生のかなり後半だったと思う。ここから、私とコンパイラとの関係が始まったのだと思う。</p>
<p>最初のうちは、Ruby の VM に興味を持っていた。なぜ Ruby なのかはよく覚えていないが、おそらく英語が読めない私にとって、日本語の資料が落ちていたのは魅力的だったのだろう。YARV の内部構造を説明するサイト（たぶん<a href="https://magazine.rubyist.net/articles/0007/0007-YarvManiacs.html">このあたり</a>）に釘付けだった。この文章を書きながらリンク先を眺めていたが、今見ても面白い。第3回：命令ディスパッチの話は、当時は理解こそできなかったものの、こんなことができるのか！すごい！と興味津々だった。これが中学2年生の初めの話。</p>
<p>インタプリタやコンパイラのことを認識した以上、何らかの言語を作りたくなるのは避けられない。
（実は HSP で電卓を作っていた頃に、小さな言語のようなものは作っていたが、BASIC よりもしょぼい文法で、AST すら知らなかったためぐちゃぐちゃのコードだったと記憶している。もう手元にはコードが残っていない。そのコードが入っている80GB HDDは分解して、ディスクを手裏剣のように投げて遊んでいた。）
今手元に残っている言語処理系で、一番古いものは <a href="https://github.com/maekawatoshiki/lit-x86">Lit</a> だ。いつのまにか C++ を覚えたようで、C++ で書いてあるし、なんとご丁寧にGitHubに置いてある。
まったく思い出せないが、どうにかgitやGitHubの使い方を覚えたようである。最初のコミットは中学2年生の夏休み頃となっている。
Lit は Ruby っぽい言語で、なんと JIT コンパイルできる。初期は手動でアセンブラ（と言っても命令に対応する16進数をハードコードしているだけだが）のようなものを書いており、それを使って JIT していたようだ。結局 LLVM を導入してしまったようだが。そもそもどのような経緯でLLVMを知ったのかも思い出せない。</p>
<p>中学3年生になると、ほとんど理解できていなかったと思われるが、Python や Clang を読んでいたような気がする。また、中学生が終わろうとしているときに、CMake があまりにも嫌いで C++ ごと捨ててしまった。同時に Rust を本格的に使い始めた。</p>
<p>そろそろこの文章を書くのも疲れてきた。ここからは簡潔にまとめよう。</p>
<p>高校生になると、本当に色々なことがあった。入門したての Rust でいきなり C言語のコンパイラを作ったり (8ccには本当にお世話になりました) 。 ブラウザを作ったり。JavaScript処理系を作ったり。JVMを作ったり。.NET VMを作ったり。型システムにも少しだけ詳しくなった。受験が嫌でコンパイラ基盤を作ったりもした。そうそう、<a href="https://prog-lang-sys-ja-slack.github.io/wiki/">プログラミング言語処理系が好きな人の集まり</a>というSlackワークスペースも開いた。受験期なのに地下鉄でLLVMのソースコードリーディングをしていた。</p>
<p>そして大学生になった。流行り病のことは完全に予想外だった。一年間完全にオンラインだったこともあり、家でずっとコンパイラのことを考えていられる生活ができたのは良かったかもしれない。これからもコンパイラのことを考え続けるだろう。</p>
<p>しかし、ひとつだけわからないのは、私はコンパイラの何が好きなのかということだ。ただ漠然と、好き、という感情があるだけで、それ以上何もない。
今後しばらくは、コンパイラの何に惹かれているのかを考えることになりそうだ。</p>
]]></content>
        </item>
        
        <item>
            <title>Third</title>
            <link>https://maekawatoshiki.github.io/posts/third/</link>
            <pubDate>Sun, 28 Feb 2021 23:30:39 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/third/</guid>
            <description></description>
            <content type="html"><![CDATA[]]></content>
        </item>
        
        <item>
            <title>Second</title>
            <link>https://maekawatoshiki.github.io/posts/second/</link>
            <pubDate>Sun, 28 Feb 2021 23:26:09 +0900</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/second/</guid>
            <description>my second page</description>
            <content type="html"><![CDATA[<p>my second page</p>
]]></content>
        </item>
        
        <item>
            <title>Welcome!!</title>
            <link>https://maekawatoshiki.github.io/posts/welcome/</link>
            <pubDate>Sun, 28 Feb 2021 14:00:00 +0000</pubDate>
            
            <guid>https://maekawatoshiki.github.io/posts/welcome/</guid>
            <description>hello world</description>
            <content type="html"><![CDATA[<p>hello world</p>
]]></content>
        </item>
        
    </channel>
</rss>
